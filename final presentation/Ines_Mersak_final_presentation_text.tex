\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[slovene]{babel}
\usepackage{lmodern}

\usepackage{amsmath,amssymb}
\usepackage[shortlabels]{enumitem}

\title{Quasi-random number generator}
\author{Ines Mer≈°ak}
\date{21.~4.~2017}


\begin{document}
    \maketitle

\section{Pseudo-random vs. quasi-random}
    Pseudo-random number:
    \begin{itemize}
        \item a computer-generated number
        \item appears to be random but is generated by an entirely deterministic process
        \item we use them to simulate a random process, for example a throw of a die
        \item a pseudo-random process is easier to produce than a genuinely random one
        \item the benefit of a pseudo-random process is that it can be used again and again to produce exactly the same numbers, which is useful for testing and fixing software
    \end{itemize}
    Quasi-random number:
    \begin{itemize}
        \item are also computer-generated and deterministic
        \item they are also called low-discrepancy numbers
        \item the discrepancy is a measure of how inhomogeneously a set of $d$-dimensional vectors are distributed in the unit hypercube
        \item low-discrepancy means the points are distributed more uniformly, with less clusters and gaps that are typical for pseudo-random numbers
        \item unlike pseudo-random numbers, low-discrepancy numbers aim not to be serially uncorrelated but instead to take the previous draws into account when determining the next number in the sequence
    \end{itemize}
%If we take a uniform random generator on $[0,1)$ and halve the interval, for each trial there is a probability of $\frac{1}{2}$ that the generated point will be in the left interval and a probability of $\frac{1}{2}$ that the point will be in the right interval. generating a point on each of these subintervals. 
%Therefore, it is possible for first $n$ generated points to coincidentally all lie in the first half of the interval, while the next point still falls within the other of the two halves with probability $\frac{1}{2}$. This is not the case with the quasirandom sequences because of the low-discrepancy requirement that has an effect of points being generated in a highly correlated manner (i.e., the next point ``knows'' where the previous points are).

\section{Quasi-random numbers -- usage}
Quasi-random numbers are useful in computational problems and are especially popular for financial Monte Carlo calculations. Quasi-Monte Carlo calculations (using sequences of quasi-random numbers to compute the integral) asimptotically converge faster than normal Monte Carlo calculations using pseudo-random numbers, even for large dimensionality of drawn vectors $d$. Monte Carlo calculations converge as: pseudo random: 1 over the square root of $N$, quasi random: close to 1 over $N$.

This was also a part of my project, as I implemented Monte Carlo integration and compared the convergence using Sobol generator vs. Mersenne Twister (the most widely used, tested, and accepted as the standard pseudo-random number generator).

\section{Sobol' numbers}
\begin{itemize}
    \item we need a new unique generating integer $\gamma(n)$ for each new draw \item easy choice is $\gamma (n) = n$, another possibility is the Gray code $\gamma (n) = G(n)$
    \item the generation is carried out on a set of integers in the interval $[1, 2^b-1]$
    \item $b$ represents the number of bits in an unsigned integer on the given computer and is typically 32
    \item denote $x_{nk}$ as the $n$th draw of Sobol' integer in dimension $k$
    \item a set of $b$ \emph{direction integers} for each dimension $k$, which are the basis of the number generation
    \item there are some additional constraints on the direction integers which I will not discuss
    \item for each dimension, we select a primitive polynomial modulo two and calculate the direction integers using the coefficients of the polynomial and binary addition
    \item from there, we calculate $x_{nk}$: depending on which bits in the binary representation of $\gamma(n)$ are set, the direction integers are XORed to produce the Sobol' integer $x_{nk}$
\end{itemize}

\section{Gray code}
\begin{itemize}
    \item any unique representation of the sequence counter $n$ can be used for $\gamma(n)$
    \item $G(n)$ switches only one single bit for every increment in $n$
    \item this means that a single XOR operation has to be carried out for each dimension 
\end{itemize}
\[ x_{nk} = x_{(n-1)k} \oplus v_{kj} \]

\section{Implementation}
\begin{itemize}
    \item used C++ -- could have used any low level language, which would make calculations fast, but went by personal preference
    \item implemented the generator as a class: the dimensionality, the number of discarded draws and whether to use gray code are set when you make an object of this class
    \item you get the next vector in the draw by calling a member function named \texttt{get\_next}
    \item the direction integers for all dimensions are calculated upon the first draw
    \item had to take care to not use data structures with too much overhead in order to make my implementation fast
    \item runs almost twice as fast as an implementation I found of some profesor at Sidney university, which I suspect is due to him generating and storing all the vectors at once
    
    \item used MATLAB and Mathematica to make the plots that you will see on today's presentation
\end{itemize}


\end{document}